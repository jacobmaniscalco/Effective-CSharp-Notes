# Chapter 2: .NET Resource Management


## Item 11: Understand .NET Resource Management

### The Garbage Collector
- You are responsible for unmanaged resources such as database connections, GDI+ objects, COM objects, and other system objects. 
- You can cause objects to stay in memory longer than you'd like because you've created links between them using event handlers or delegates. 
- The GC's Mark and Compact algorithm efficiently detect relationships and remove unreachable webs of objects in their entirety. The GC determines if an object is reachable by walking the object tree from the application's root object instead of forcing each object to keep trach of references to it. 
- The garbage collector compacts the managed heap each time it runs. Compacting the heap moves each live object in the managed heap so  that the free space is located in one contiguous block of memory. 
- The two mechanisms that developers can use to control the lifetimes of unmanaged resources are `finalizers` and the `IDisposable` interface.
- Finalizers are called by the garbage collector at some time after an object becomes garbage. 
- Finalizers can have a big impact on performance, but are necessary for unmanaged code to avoid resource leaks. 

## Item 12: Prefer Member Initializers to Assignment Statements
- The best way to make sure member variables and constructors don't get out of sync is to initialize variables where you declare them instead of in the body of every constructor. You should use the initializer syntax for both static and instance variables. 
```
public class MyClass
{
    //declare the collection, and initialize it
    private List<string> labels = new List<string>();
}
```
- The compiler generates code at the beginning of each constructor to execute all the initializers you have defined for your instance member variables. When you add a new constructor, labels get initialized. 
- The statements generated by initializers are placed in object code before the body of your constructors. Initializers execute before the base class constructor for your type executes, and the yare executed in the order in which the variables are declared in your class. 
### 3 Cases When You Should Not Use the Initializer Syntax
1. When you are initializing the object to 0, or null
```
public struct MyValType
{
    // elided
}
MyValType myVal1;  // initialized to 0
MyValType myVal2 = new MyValType(); // also 0
```
2. When you create multiple initializations for the same object. Only use the initializer syntax for variables that receive the same initialization in all constructors.
```
public class MyClass2
{
    // declare the collection, and initialize it.
     private List<string> labels = new List<string>();
    MyClass2()
    {
    }
 MyClass2(int size)
    {
        labels = new List<string>(size);
    }
}
```
When you create a new `MyClass2`, specifying the size of the collection, you create two array lists. One is immediately garbage. The variable initialzer executes before any every constructor. The constructor body creates the second array list.

3. The final reason to move initialization into the constructor body is to facilitate exception handling. 

## Item 13: Use Proper Initialization for Static Class Members
Singleton example:
```
public class MySingleton
{
    private static readonly MySingleton theOneAndOnly = new MySingleton();

    public static MySingleton TheOnly
    {
        get { return theOneAndOnly };
    }

    private MySingleton()
    { }
}
```
OR
```
public class MySingleton2
{
    private static readonly MySingleton2 theOneAndOnly;
    static MySingleton2()
    {
        theOneAndOnly = new MySingleton2();
    }
    public static MySingleton2 TheOnly
    {
        get { return theOneAndOnly; }
    }
    private MySingleton2()
    {
    }
 // remainder elided
}

```

## Item 14: Minimize Duplicate Initialization Logic
- Constructor initializers allow one constructor to call another constructor.
Example:
```
public class MyClass
{
    // collection of data
    private List<ImportantData> coll;
    // Name of the instance:
    private string name;
    public MyClass() :
        this(0, "")
    {
    }
    public MyClass(int initialCount) :
        this(initialCount, string.Empty)
    {
    }
 public MyClass(int initialCount, string name)
    {
        coll = (initialCount > 0) ?
        new List<ImportantData>(initialCount) :
        new List<ImportantData>();
        this.name = name;
    }
}
```
This can be improved upon using default parameters:
```
public class MyClass
{
    // collection of data
    private List<ImportantData> coll;
    // Name of the instance:
    private string name;
    // Needed to satisfy the new() constraint.
    public MyClass() :
        this(0, string.Empty)
    {
    }
    public MyClass(int initialCount = 0, string name = "")
    {
        coll = (initialCount > 0) ?
        new List<ImportantData>(initialCount) :
        new List<ImportantData>();
        this.name = name;
    }
}
```
- There are tradeoffs in choosing default parameters over using multiple overloads. Default parameters create more options for your users.
- In general, you should prefer default values to overloaded constructors.

### Order of Operations For Constructing the First Instance of a Type
1. Static variable storage is set to 0
2. Static variable initializers execute.
3. Static constructors for the base class execute.
4. The static constructor executes.
5. Instance variable storage is set to 0.
6. Instance variable initializers execute 
7. The appropriate base class instance constructor executes
8. The instance constructor executes. 
- Subsequent instances of the same type start at step 5 because the class initializers execute only once. Also, steps 6 nd 7 are optimized so that constructor initializers cause the compiler to remove duplicate instructions.

## Item 15: Avoid Creating Unnecessary Objects
- An example of a  bad practice is to allocate GDI objects in a Windows paint handler
### 3 Ways to Minimize Number of Allocations
1. Promote often-used local variables to member variables
2. Use dependency injection to create and reuse objects that represent common instances of a given type.
3. Building the final value for immutable types
```
protected override void OnPaint(PaintEventArgs e)
{
    // Bad. Created the same font every paint event.
    using (Font MyFont = new Font("Arial", 10.0f))
    {
        e.Graphics.DrawString(DateTime.Now.ToString(),
            MyFont, Brushes.Black, new PointF(0, 0));
    }
    base.OnPaint(e);
}
```
If OnPaint is called often, a new Font object is created each time while the Font object maintains the same properties.

A possible fix would be:
```
private readonly Font myFont =
    new Font("Arial", 10.0f);
 protected override void OnPaint(PaintEventArgs e)
{
    e.Graphics.DrawString(DateTime.Now.ToString(),
        myFont, Brushes.Black, new PointF(0, 0));
    base.OnPaint(e);
}
```
- You should promote instance variables to member variables when they are reference types (value types dont matter) and they will be used in routines that are called frequently. 
- `Brushes.Black` is a good example of creating static member variables for commonly used instances of the reference types you need.
A simplified version of the black brush that is provided (using a number of static Brush objects, each with a different common color):
```
private static Brush blackBrush;
public static Brush Black
{
    get
    {
        if (blackBrush == null)
            blackBrush = new SolidBrush(Color.Black);
        return blackBrush;
    }
}
```
The first time you request a black brush, the Brushes class creates it, otherwise, a reference is returned to the same handle whenever it is requested again. Furthermore, if the application does not need a particular resource, say a green brush, it never gets created. However, this means that objects could be in memory longer than necessary, as you are not able to dispose of unmanaged resources because you cant know when to call the Dispose() method.

The following code: 
```
string msg = "Hello, ";
msg += thisUser.Name;
msg += ". Today is ";
msg += System.DateTime.Now.ToString();
```
is just as inefficient as if you had written this:
```
string msg = "Hello, ";
// Not legal, for illustration only:
string tmp1 = new String(msg + thisUser.Name);
msg = tmp1; // "Hello " is garbage.
string tmp2 = new String(msg + ". Today is ");
msg = tmp2; // "Hello <user>" is garbage.
string tmp3 = new String(msg + DateTime.Now.ToString());
msg = tmp3; // "Hello <user>. Today is " is garbage.
```
- When your design calls for immutable types, consider creating builder objects to facilitate the multiphase construction of the final object. This provides a way for users of your class to construct an object in steps, while maintaining the immutability of your tpye.

## Item 16: Never Call Virtual Functions In Constructors
```
class B
{
    protected B()
    {
        VFunc();
    }
    protected virtual void VFunc()
    {
        Console.WriteLine("VFunc in B");
    }
}
 class Derived : B
{
    private readonly string msg = "Set by initializer";
    public Derived(string msg)
    {
        this.msg = msg;
    }
    protected override void VFunc()
    {
        Console.WriteLine(msg);
    }
    public static void Main()
    {
        var d = new Derived("Constructed in main");
    }
}
```
The above code outputs "Set by initializer" 

- Calling virtual functions in constructors make your code extremely sensitive to the implementation details in derived classes. 

## Item 17: Implement the Standard Dispose Pattern
- The root base class in the class hierarchy should do the following:
    1. Implement the `IDisposable` interface to free resources
    2. It should add a finalizer as a defensive mechanism if and only if your class directly contains an unmanaged resource
    3. Both Dispose and the finalizer (if present) delegate the work of freeing resources to a virtual method that derived classes can override for their own resource management needs.
- The derived classes need to do the following:
    1. Override the virtual method only when the dervied class must free its own resources
    2. Implement a finalizer if and only if one of its direct member fields is an unmanaged resource
    3. Remember to call the base class version of the function
- The implementation of your `IDisposable.Dispose()` methos is responsible for four tasks:
    1. Freeing all unmanaged resources.
    2. Freeing all managed resources(this includes unhooking events)
    3. Setting a state flag to indicate that the object has been disposed of. You need to check this state and throw `ObjectDisposed` exceptions in your public members if any get called after disposing of an object
    4. Suppressing finalization. You call GC.SuppressFinalize(this) to accomplish this task.
